# 07 Aug 2019

Tags: LeetCode

## Reverse an array of characters in-place

Must have O(1) space complexity.
Modify the input array in-place.

First solution:

```javascript
const reverseString = (s) => {
  const z = s.length / 2;

  for (let i = 0; i < s.length; i++) {
    if (i < z) {
      const x = x[i];
      x[i] = x[s.length - 1 - i];
    }
  }
};
```

Got this in about 35 minutes.

Approach:

- switch the corresponding elements (first and last, second and second-to-last, 
  etc.)
- only switch while the loop index is less than half the length of the array.

The second bit feels like a kludge.
There must be a nicer way to do this.

Actually, this seems to be the way that people are doing it, basically.
There are few messy things here.

Improvements:

- Instead of checking that `i < s.length / 2`, just limit the loop to 
  `s.length / 2`.

```javascript
const reverseString = (s) => {
  // cache this expression
  // if written inline in the for-loop, it will be recomputed for each iteration
  const x = s.length / 2;

  for (let i = 0; i < x; i++) {
    const temp = s[i];
    s[i] = s[s.length - 1 - i];
    s[s.length - 1 - i] = temp;
  }
};
```

This has O(1) space complexity and O(n) time complexity.

One thing I noticed when running this through LeetCode is that the execution 
time is faster if I add an `if` statement to the loop body:

```javascript
const reverseString = (s) => {
  // cache this expression
  // if written inline in the for-loop, it will be recomputed for each iteration
  const x = s.length / 2;

  for (let i = 0; i < x; i++) {
    if (i < x) {
      const temp = s[i];
      s[i] = s[s.length - 1 - i];
      s[s.length - 1 - i] = temp;
    }
  }
};
```

LeetCode says that this version is faster than 10% more of the solutions.
I expected the conditional to slow it down.

## Remove duplicates from sorted array in-place

Must have O(1) space complexity.
Modify the input array in-place.

Solution:

```javascript
const removeDuplicates = (nums) => {
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] === nums[j]) {
        nums.splice(i,1);
        i = i - 1;
        j = j - 1;
      }
    }
  }

  return nums.length;
};
```

Space complexity: O(1)
Time complexity: O(n^2)

This took me 35 minutes to completed.

LeetCode's solution:

```javascript
const removeDuplicates = (nums) => {
  if (nums.length === 0) {
    return 0;
  }

  let i = 0;

  for (let j = 1; j < nums.length; j++) {
    if (nums[i] !== nums[j]) {
      i++;
      nums[i] = nums[j];
    }
  }

  return nums.length;
};
```

How does this work?

- Check when two adjacent elements aren't equal. (this is different from my
  approach which was to check when there were two duplicate elements).
- When two elements aren't equal:
  - Advance the counter `i` by one.
  - Move `nums[j]` to `nums[i]`.

```
[1, 1, 2]

// i === 0, j === 1
// nums[i] === 1
// nums[j] === 1
// i === 0, j === 2
// nums[i] === 1
// nums[i] === 2
// i === 1
// nums[1] = 2
```
