# 16 January 2019

## Monad Transformers Step by Step

Notes on ["Monad Transformers Step by Step"](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.71.596&rep=rep1&type=pdf)
by Martin Grabmueller.

Used to combine the behavior of more than one monad.

Examples:

- IO with error handling
- State and error handling
- IO and state

```haskell
-- variable name
type Name = String

-- programs are made up of expressions
data Exp 
  = Lit Integer
  | Var Name
  | Plus Exp Exp
  | Abs Name Exp -- "abstraction" is another name for function
  | App Exp Exp -- "application"
  deriving (Show)

-- programs are evaluated to values
data Value 
  = IntVal Integer
  | FunVal Env Nam eExp

type Env = Map.Map Name Value
```

### Implementation #1

First implementation of evaluation:

```haskell
eval :: Env -> Exp -> Value
-- integer evaluates to itself
eval _ (Lit i) = IntVal i
-- variable evaluates to its value
-- fromJust throws an exception if value is Nothing
eval env (Var n) = fromJust (Map.lookup n env) 
-- evaluate both expressions and then add the result
eval env (Plus e1 e2) = let IntVal i1 = eval env e1
                            IntVal i2 = eval env e2
                        in IntVal (i1 + i2)
-- abstractions evaluate to function values
eval env (Abs n e) = FunVal env n e
-- evaluate the function arguments
-- if the first argument evaluates to a function
-- insert the argument to the function into the environment
-- evaluate the function's body with that environment
eval env (App e1 e2) = let val1 = eval env e1
                           val2 = eval env e2
                       in case val1 of
                            -- incomplete pattern matching here
                            FunVal env' n body -> eval (Map.insert n val2 env') body     
```

The first step to using a monad for evaluation is to define the monad.

### Implementation #2

```haskell
type Eval a = Identity a

runEval :: Eval a -> a
runEval eval' = runIdentity eval'

eval :: Env -> Exp -> Eval Value
eval _ (Lit i) = return $ IntVal i
-- This is interesting:
-- Map.lookup calls the `fail` function if the lookup fails
-- `fail` is defined in Control.Applicative
-- dispatches to the fail function for whatever monad is in the context.
eval env (Var n) = Map.lookup n env
eval env (Plus e1 e2) = do 
  IntVal i1 <- eval env e1
  IntVal i2 <- eval env e2
  return $ IntVal (i1 + i2) 
eval env (Abs n e) = return $ FunVal env n e
eval env (App e1 e2) = do
  val1 <- eval env e1
  val2 <- eval env e2
  case val1 of
    FunVal env' n body ->
      eval (Map.insert n val2 env') body

exampleExp = Lit 1

evaluated = runEval (eval Map.empty exampleExp) -- IntVal 1
```

Can generalize the type of `eval` to:

```haskell
eval :: Monad m => Env -> Exp -> m Value
```

This enables us to change the monad without updating other code.
