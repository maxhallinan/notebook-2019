# 07 February 2019

> The very best startup ideas tend to have three things in common: they're
> something the founders themselves want, that they themselves can build, and
> that few others realize are worth doing.

> When you have an idea for a startup, ask yourself: who wants this right now?
> Who wants this so much that they'll use it even when it's a crappy version one
> made by a two-person startup they've never heard of? If you can't answer that,
> the idea is probably bad.

> The verb you want to be using with respect to startup ideas is not "think up"
> but "notice".
> At YC we call ideas that grow naturally out of the founders' own experiences
> "organic" startup ideas.
> The most successful startups almost all begin this way.

> Live in the future, then build what's missing.

> Most things that are missing will take some time to see.
> You almost have to trick yourself into seeing the ideas around you.
>
> But you _know_ the ideas are out there.
> This is not one of those problems where there might not be an answer.
> It's impossibly unlikely that this is the exact moment when technological
> progress stops.
> You can be sure that people are going to build things in the next few years
> that will make you think "What did I do before x?"

> What you need to do is turn off the filters that usually prevent you from
> seeing them.
> The most powerful is simply taking the current state of the world for granted.
> Even the most radically open-minded of us mostly do that.
> You couldn't get from your bed to the front door if you stopped to question
> everything.
>
> But if you're looking for startup ideas you can sacrifice some of the efficiency
> of taking the status quo for granted and start to question things.

> Pay particular attention to things that chafe you.
> The advantage of taking the status quo for granted is not just that it makes
> life (locally) more efficient, but also that it makes life more tolerable.

> Since what you need to do here is loosen up your own mind, it may be best not
> to make too much of a direct frontal attack on the problem &mdash; i.e. to sit
> down and try to think of ideas.
> The best plan may be just to keep a background process running, looking for things
> that seem to be missing.
> Work on hard problems, driven mainly by curiosity, but have a second self watching
> over your shoulder, taking note of gaps and anomalies.

Problems I have

- There is no language I like to use to write programs that run in a browser
- I wish I could search my local code by type signature
- I get confused by complicated Haskell types
- I get confused by all the numeric types in Haskell (which is used for what?)
- I am frustrated that my colleagues are more focused on the technical aspects of
  programming and do not think of programming as problem solving, the solutions
  just being expressed as code.
- I am frustrated by not having enough time
- I wish I could run one command, like `create-react-app`, to install a database
  or even bootstrap an entire backend, so I can just immediately start working
  on an application without so much project setup.
- When I am writing software, I don't have a repeatable process for problem solving
- When I am thinking about problems I'm solving, I don't know if a solution already exists
- As a self-taught developer, I don't always know about theory would help me
  solve the problems I am working on. Here are some examples of questions I've 
  had recently:
  - What is the platonic form of Lisp?
  - How would I compile a high-level language to web assembly?
      - What are the topics I need to know to compile to web assembly?
      - What is a virtual machine?
      - How does one write a virtual machine?
      - How does one implement garbage collection?
      - How does one implement data structures?
      - What is an assembly language?
  - I want to evaluate several state monads, using each final state as the initial 
    state of the next monad in the sequence
- As a self-taught developer, I would benefit from mentorship so that I don't 
  spend time re-inventing wheels or can shorten the feedback loop, benefit from
  prior art. The problem is, it is hard to find a mentor.

  > 1/ We independent researchers like to see ourseveles as fearless foragers. 
  > But if we're not careful, we often end up retracing well worn paths
  > 2/ In the #futureofcoding community, we get into various paradigms/topics: 
  > blocks, node-and-wires, projectional editors, DSLs, VPLs, OOP, FP, FRP, 
  > LISPs, type systems, smalltalks, debuggers, viualizers, direct manipulation, 
  > WYSIWYG, program synthesis, formal methods, ...
  > 3/ But breaking into the literature from outside academic for a new 
  > field/topic is overwhelming! So we strap on the Silicon Valley mindset and 
  > start hacking 👨‍💻 ...only to later find out that we could've avoid 
  > the trouble if we knew our history
  > 4/ How do we help independent researchers sittuate themselves?
  > 5/ Finding a advisor is the gold standard (like I did with @jonathoda), but 
  > that's not an option for everyone
  > 6/ New researchers need to know the hard, unsolved problems. As well as the 
  > solutions to the solved problems for easy copying. They need the classic 
  > papers & notable people. They need to know which conferences and workshops 
  > to submit to. They need to know who to follow on Twitter
  > 7/ My proposal: nominate a person to be the "authority" for a topic, to keep 
  > a roughly up-to-date list of notable papers, videos, links, communities, 
  > and, importantly, contextualizing why each is important
  > 8/ It'd kind of be like a "living survey paper"
  > 9/ And we should convince someone to fund these people for their efforts!
  > &mdash; [@stevekrouse](https://twitter.com/stevekrouse/status/1091422982763937792)

  - George Polya's method described in "How to Solve It" feels like it could be
    instrumental here
  - Two things I need to deal with this problem:
    - a framework for thinking through the problem independently - something that
      saves me from myself but doesn't make me dependent on someone else
    - a place to ask questions about what i don't know, about what i'm trying to achieve
      _a place to discover what i don't know that i don't know_.
    - "priors.xyz", "george"
