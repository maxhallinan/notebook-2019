# 28 January 2019

## The Roots of Lisp by Paul Graham

### Expression

An expression is either:

- An atom (a sequence of characters)
- A list of zero or more expressions
  - Separated by whitespace
  - Enclosed by parens

When an expression is a list, the first element is called the "operator" and
the remaining elements are "arguments".

### Seven primitive operators

- `(quote x)`:
  - `(quote x)` returns `x`
  - `'x` is syntax sugar for `(quote x)`
  - quoting a list protects it from evaluation
  - e.g. `(atom (atom x))` returns `t` because `x` is an atom and `t` is an
    atom
  - but `(atom '(atom x))` returns `()` because `'(atom x)` is a list, not the
    application of `atom` to `x`.
- `(atom x)`:
  - `(atom x)` returns `t` if x is an atom, otherwise `()`
  - the atom `t` is used to represent truth
  - `()` the empty list is used to represent falsehood
- `(eq x y)`:
  - takes two arguments, returns true if arguments are the same atom, otherwise
    false
  - `(eq x x)` returns `t`
  - `(eq x y)` returns `()`
- `(car xs)`
  - a partial function of lists
  - returns the first element in the list
  - `(car '(x))` returns `x`
- `(cdr xs)`
  - a partial function of lists
  - returns the list minus its first element
  - `(car '(x))` returns `()`
  - `(car '(x y z))` returns `(y z)`
- `(cons x ys)`
  - lifts x into the list `ys`
- `(cond (p1, e1) ... (pn, en))`
  - takes an arbitrary number of predicate/expression pairs
  - returns the value of the first expression whose predicate evaluates to `t`

### Denoting functions

#### `lambda`

All functions are lambda functions.
Function definition is `(lambda (p1 ... pn) e)`.
Function application is `((lambda (p1 ... pn) e) x1 ... xn)`, where `x1 ... xn`
are argument expressions bound to the parameters `p1 ... pn`.
`e` is an expression evaluated in lexically scoped environment containing the 
parameters.
Parameters can be functions.

#### `label`

`label` is used to bind a function to a variable name: 
`(label identity (lambda (x) x))`.
This anonymous function is not bound to the symbol `identity`.
The function can be called by placing the symbol in the operator position: 
`(identity 1)`.
This enables recursively defined functions.

A common alias for the `label`/`lambda` composition is `defun`: 

```lisp
(label defun 
  (lambda (name, args, expr) 
    (label 'name 
      (lambda 'args, 'expr))))
```

### Some functions

`null`: returns `t` if `x` is `'()`, otherwise `'()`.

```lisp
(defun null (x) 
  (eq x '()))
```

`and`: returns `t` if both `x` and `y` evaluate to `t`.

```lisp
(defun and (x y) 
  (cond 
    (cond (x (cond y 't) ('t '()))) 
          ('t '())))
```

`not`: returns `t` if `x` is `'()`, otherwise `'()`.

```lisp
(defun not (x) 
  (cond (x '()) 
        ('t 't)))
```

`append`: the concatenation of two lists.

```lisp
(defun append (x y)
  (cond ((null (car x)) 'y) 
        ('t (cons (car x) (append (cdr x) y)))))
```

`pair`: zips two lists.

```lisp
(defun pair (x y) 
  (cond ((and (null (car x)) (null (car y))) '()) 
        ((and (not (atom x)) (not (atom y))) 
          (cons (list (car x) (car y)) 
                (pair (cdr x) (cdr y))))))
```

`assoc`: takes an atom `x` and a list `y` in the form returned by `pair`, and 
returns the second item in the first element of `y` whose first item matches `x`.

```lisp
(defun assoc (x y) 
  (cond ((eq x (car (car y))) (cdr (car y))) 
        ('t (assoc x (cdr y)))))
```
