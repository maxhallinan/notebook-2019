# Notes about ProseMirror

## Library guide

### Introduction

> The main principle of ProseMirror is that your code gets full control over the
> document and what happens to it.
>
> [ProseMirror Guide](https://prosemirror.net/docs/guide/)

The document is a data structure.
All updates to the document go through a single point.

ProseMirror's essential modules:

- `prosemirror-model`: the document model
    - the document model is the data structure that describes the document
    - the document is the content of the editor
- `prosemirror-state`: the editor state
    - the editor state includes more things than the document
    - a transaction system for changing state
    - the current selection
- `prosemirror-view`: the editor view
    - renders the editor state as an element in the browser
    - handles user interactions with the editor
- `prosemirror-transform`: modify the document
    - modifications are recordable and replayable

To initialize a ProseMirror instance, you create first create a state and then
use the state to create a view.

```javascript
import {schema} from 'prosemirror-schema-basic';
import {EditorState} from 'prosemirror-state';
import {EditorView} from 'prosemirror-view';

let state = new EditorState({schema});
let view = new EditorView({state});
```

The document conforms to the *schema*.
The state will use the schema to generate an empty document.

### How is the editor updated?

- The user interacts with the editor (the view).
- A user interaction creates a transaction.
  - The transaction describes the change to the state.
- A new state is created by applying the transaction to the current state.
- The view is updated with the new state.

#### Transactions

Transactions are generated by:

- typing
- pressing a button in the editor UI
- interacting with the view in some other way

A transaction describes a change that has been made to the editor state.
A transaction must be _applied_ to create a new state.
The new state updates the view.

**Plugins** are a way to hook into the transaction/state loop.

`dispatchTransaction` is a callback that is called whenever a transaction is
created.


```javascript
const view = new EditorView(document.body, {
  schema,
  // Called with the latest transaction.
  dispatchTransaction(transaction) {
    // Here you can transform the transaction in any way.

    // Then you must apply the transaction to the state to create a new state.
    const newState = view.state.apply(transaction);

    // Finally, update the view with the new state.
    view.updateState(newState);
  }
})
```

#### Plugins

Plugins are bound to the EditorState because they need access to the state
transactions.

Examples of plugins:

- keymap bindings
- undo/redo history

#### Actions

A command is a special kind of function.
Commands represent editing actions like undo and redo.
Commands are bound to keys, hooked up to menus, and exposed to the user in other
ways.

**The `keymap` plugin from "prosemirror-keymap" and the `baseKeymap` in `prosemirror-commands` is an essential component for
setting up an editor.**J

#### Content

`state.doc` is the state's document.
A document can be created by using the schema to parse a string.
You can initialize an editor state with a document using the `doc` option.
In this case, you don't have to provide the schema explicitly, the schema will
be taken from the doc itself.

### Documents

#### Structure

- A document is a tree of nodes.
- Each node contains a fragment.
- A fragment is a collection of 0 or more child nodes.
- A document is more specifically a tree of **block** nodes.
  - Most of the leaf nodes are **textblocks**.
  - There are empty leaf blocks like a horizontal rule.

**Nodes**

A few relevant attributes of a node object:

- `isBlock` and `isInline`
- `inlineContent`: true when the node expects inline nodes as content.
- `isTextblock`: true when a node has inline content.
- `isLeaf`: true when a node has no content. 

_Examples_

- Block: a blockquote, because it can contain other block nodes
- Textblock: a paragraph, which can only contain inline nodes
- Block leaf node: horizontal rule
- Inline leaf node: text, strong, em, and inline images

**Representation of inline content**

The DOM uses a hierarchical representation of inline content.
For example, a paragraph containing a `strong` tag containg an `em` tag is a
tree, where the text of the `em` tag is the leaf node.
ProseMirror uses a flat representation for inline content.
Each block level element has a sequence of inline elements.
These inline elements contain both text and markup data.

Implications for inline text:

- Positions can be represented using character offsets rather than
  tree path.
- Inline content is easier to manipulate because you don't need to do tree
  manipulation.

**The markup data for inline content is called `marks`**.

Other details:

- Adjacent text nodes with the same marks are combined.
- Empty text nodes aren't allowed.

**Identity and peristence**

Nodes are just values - they are not stateful objects.
A document is an immutable data structure.
Updating the document creates a copy of the original with the changes applied.

Reasons

- Efficient view updates
- Features like diffing and collaborative editing

A Node:

```javascript
{
  type: NodeType,
  content: Fragment [Node],
  attrs: Object,
  marks: [Mark {type: MarkType, attrs: Object}]
}
```

- The NodeType and MarkType is derived from the Schema.
- The attributes object contains things like the alt text and url for an image 
  node.
- The document itself is just a Node.
- The Schema determines which Node types can be children of which other Nodes.

To create Node types, you update the schema:

```javascript
import {schema} from "prosemirror-schema-basic";

// node(<node type>, <attributes>, <content>)
let doc = schema.node("doc", null, [
  schema.node("paragraph", null, [schema.text("One")]),
  schema.node("horizontal_rule"),
  schema.node("paragraph", null, [schema.text("Two")]),
]);
```

#### Indexing

A ProseMirror document supports two types of indexing:

- Tree
  - Use tree traversal to select a node
- Flat sequence of tokens
  - Integer for index in token sequence
  - The start of the document, right before the first token, is position 0
  - Both entering and exiting a non-leaf node counts as 1 token
    - If a document starts with a paragraph, the paragraph is at index 1.
  - Each character in a text node counts as 1 token.
      - In a paragraph containing the word "hi", position 2 is after the "h", 
        position 3 is after the "i", and position 4 is after the paragraph.
  - Leaf nodes without content count as 1 token.

```
0   1 2 3 4    5
 <p> O n e </p>
```

- `nodeSize`: the size of the entire node
- `content.size`: the size of the node's content

#### Slices

The content between two positions in a document is called a slice.
Slices are different than nodes and fragments because the content of a slice
might include a piece of a node, e.g. if something has selected an opening 
paragraph tag but not the closing tag.

A slice is represented by the `Slice` data structure.
`Node`s have a `slice` method that can be used to slice the node.

```javascript
// the doc holds two paragraphs containing text "a" and "b"
let slice1 = doc.slice(0,3) // first paragraph
let slice2 = doc.slice(1,5) // start of first paragraph to end of second
```

#### Changing a document

Use a **document transformation** to change the document.
A document transformation is the basis for a transaction.
Document transformations don't involve directly touching the nodes.

### Schemas

Every document is associated with a schema.

Schemas describe:

- what nodes occur in the document
- how the nodes can be nested

You can create your own schema to describe your document:

This creates a schema using a spec object:

```javascript
const trivialSchema = new Schema({
  nodes: {
    doc: {content: 'paragraph+'},
    paragraph: {content: 'text*'},
    text: {inline: true},
  },
});
```

**Content expressions**

The strings in the `content` fields above are called **content expressions**.
This is a **[guide for content expression syntax](https://prosemirror.net/docs/guide/#schema.content_expressions)**.

- `paragraph+` means "one or more paragraphs nodes".
- `text*` means "zero or more text nodes".
- `inline`: indicates the node is inline

**Marks**

Marks are used to add metadata to inline content.
The schema also specifies marks.

```javascript
const trivialSchema = new Schema({
  nodes: {
    doc: {
      content: 'paragraph+',
      marks: "_", // "_" is a wildcard
    },
    paragraph: {
      content: 'text*',
      marks: "strong em", // a space-separated string of valid marks
    },
    text: {
      inline: true,
    },
  },
  marks: {
    strong: {},
    em: {},
  },
});
```

Each node specification has a nodes attribute that specifies the set of valid 
marks for that node.

**Attributes**
