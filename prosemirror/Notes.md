# Notes about ProseMirror

## Library guide

### Introduction

> The main principle of ProseMirror is that your code gets full control over the
> document and what happens to it.
>
> [ProseMirror Guide](https://prosemirror.net/docs/guide/)

The document is a data structure.
All updates to the document go through a single point.

ProseMirror's essential modules:

- `prosemirror-model`: the document model
    - the document model is the data structure that describes the document
    - the document is the content of the editor
- `prosemirror-state`: the editor state
    - the editor state includes more things than the document
    - a transaction system for changing state
    - the current selection
- `prosemirror-view`: the editor view
    - renders the editor state as an element in the browser
    - handles user interactions with the editor
- `prosemirror-transform`: modify the document
    - modifications are recordable and replayable

To initialize a ProseMirror instance, you create first create a state and then
use the state to create a view.

```javascript
import {schema} from 'prosemirror-schema-basic';
import {EditorState} from 'prosemirror-state';
import {EditorView} from 'prosemirror-view';

let state = new EditorState({schema});
let view = new EditorView({state});
```

The document conforms to the *schema*.
The state will use the schema to generate an empty document.

### How is the editor updated?

- The user interacts with the editor (the view).
- A user interaction creates a transaction.
  - The transaction describes the change to the state.
- A new state is created by applying the transaction to the current state.
- The view is updated with the new state.

#### Transactions

Transactions are generated by:

- typing
- pressing a button in the editor UI
- interacting with the view in some other way

A transaction describes a change that has been made to the editor state.
A transaction must be _applied_ to create a new state.
The new state updates the view.

**Plugins** are a way to hook into the transaction/state loop.

`dispatchTransaction` is a callback that is called whenever a transaction is
created.


```javascript
const view = new EditorView(document.body, {
  schema,
  // Called with the latest transaction.
  dispatchTransaction(transaction) {
    // Here you can transform the transaction in any way.

    // Then you must apply the transaction to the state to create a new state.
    const newState = view.state.apply(transaction);

    // Finally, update the view with the new state.
    view.updateState(newState);
  }
})
```

#### Plugins

Plugins are bound to the EditorState because they need access to the state
transactions.

Examples of plugins:

- keymap bindings
- undo/redo history

#### Actions

A command is a special kind of function.
Commands represent editing actions like undo and redo.
Commands are bound to keys, hooked up to menus, and exposed to the user in other
ways.

**The `keymap` plugin from "prosemirror-keymap" and the `baseKeymap` in `prosemirror-commands` is an essential component for
setting up an editor.**J

#### Content

`state.doc` is the state's document.
A document can be created by using the schema to parse a string.
You can initialize an editor state with a document using the `doc` option.
In this case, you don't have to provide the schema explicitly, the schema will
be taken from the doc itself.

### Documents

#### Structure

- A document is a tree of nodes.
- Each node contains a fragment.
- A fragment is a collection of 0 or more child nodes.
- A document is more specifically a tree of **block** nodes.
  - Most of the leaf nodes are **textblocks**.
  - There are empty leaf blocks like a horizontal rule.

**Nodes**

A few relevant attributes of a node object:

- `isBlock` and `isInline`
- `inlineContent`: true when the node expects inline nodes as content.
- `isTextblock`: true when a node has inline content.
- `isLeaf`: true when a node has no content. 

_Examples_

- Block: a blockquote, because it can contain other block nodes
- Textblock: a paragraph, which can only contain inline nodes
- Block leaf node: horizontal rule
- Inline leaf node: text, strong, em, and inline images

**Representation of inline content**

The DOM uses a hierarchical representation of inline content.
For example, a paragraph containing a `strong` tag containg an `em` tag is a
tree, where the text of the `em` tag is the leaf node.
ProseMirror uses a flat representation for inline content.
Each block level element has a sequence of inline elements.
These inline elements contain both text and markup data.

Implications for inline text:

- Positions can be represented using character offsets rather than
  tree path.
- Inline content is easier to manipulate because you don't need to do tree
  manipulation.

**The markup data for inline content is called `marks`**.

Other details:

- Adjacent text nodes with the same marks are combined.
- Empty text nodes aren't allowed.

**Identity and peristence**

Nodes are just values - they are not stateful objects.
A document is an immutable data structure.
Updating the document creates a copy of the original with the changes applied.

Reasons

- Efficient view updates
- Features like diffing and collaborative editing

A Node:

```javascript
{
  type: NodeType,
  content: Fragment [Node],
  attrs: Object,
  marks: [Mark {type: MarkType, attrs: Object}]
}
```

- The NodeType and MarkType is derived from the Schema.
- The attributes object contains things like the alt text and url for an image 
  node.
- The document itself is just a Node.
- The Schema determines which Node types can be children of which other Nodes.

To create Node types, you update the schema:

```javascript
import {schema} from "prosemirror-schema-basic";

// node(<node type>, <attributes>, <content>)
let doc = schema.node("doc", null, [
  schema.node("paragraph", null, [schema.text("One")]),
  schema.node("horizontal_rule"),
  schema.node("paragraph", null, [schema.text("Two")]),
]);
```

#### Indexing

A ProseMirror document supports two types of indexing:

- Tree
  - Use tree traversal to select a node
- Flat sequence of tokens
  - Integer for index in token sequence
  - The start of the document, right before the first token, is position 0
  - Both entering and exiting a non-leaf node counts as 1 token
    - If a document starts with a paragraph, the paragraph is at index 1.
  - Each character in a text node counts as 1 token.
      - In a paragraph containing the word "hi", position 2 is after the "h", 
        position 3 is after the "i", and position 4 is after the paragraph.
  - Leaf nodes without content count as 1 token.

```
0   1 2 3 4    5
 <p> O n e </p>
```

- `nodeSize`: the size of the entire node
- `content.size`: the size of the node's content

#### Slices

The content between two positions in a document is called a slice.
Slices are different than nodes and fragments because the content of a slice
might include a piece of a node, e.g. if something has selected an opening 
paragraph tag but not the closing tag.

A slice is represented by the `Slice` data structure.
`Node`s have a `slice` method that can be used to slice the node.

```javascript
// the doc holds two paragraphs containing text "a" and "b"
let slice1 = doc.slice(0,3) // first paragraph
let slice2 = doc.slice(1,5) // start of first paragraph to end of second
```

#### Changing a document

Use a **document transformation** to change the document.
A document transformation is the basis for a transaction.
Document transformations don't involve directly touching the nodes.

### Schemas

Every document is associated with a schema.

Schemas describe:

- what nodes occur in the document
- how the nodes can be nested

You can create your own schema to describe your document:

This creates a schema using a spec object:

```javascript
const trivialSchema = new Schema({
  nodes: {
    doc: {content: 'paragraph+'},
    paragraph: {content: 'text*'},
    text: {inline: true},
  },
});
```

**Content expressions**

The strings in the `content` fields above are called **content expressions**.
This is a **[guide for content expression syntax](https://prosemirror.net/docs/guide/#schema.content_expressions)**.

- `paragraph+` means "one or more paragraphs nodes".
- `text*` means "zero or more text nodes".
- `inline`: indicates the node is inline

**Marks**

Marks are used to add metadata to inline content.
The schema also specifies marks.

```javascript
const trivialSchema = new Schema({
  nodes: {
    doc: {
      content: 'paragraph+',
      marks: "_", // "_" is a wildcard
    },
    paragraph: {
      content: 'text*',
      marks: "strong em", // a space-separated string of valid marks
    },
    text: {
      inline: true,
    },
  },
  marks: {
    strong: {},
    em: {},
  },
});
```

Each node specification has a nodes attribute that specifies the set of valid 
marks for that node.

**Attributes**

**Serialization and Parsing**

Two kinds of serialization/parsing:

- to/from JSON
- to/from DOM

_DOM Serialization_

Each node must have a DOM representation.
The `toDom` method of a node specifies how it displayed in the DOM.

`toDom` can return:
  - a DOM node
  - a string, which is interpreted as a text element
  - an array where:
    - the first element is a string, the name of the DOM element
    - the second element is a plain object, the attributes of the element
    - elements after that are children of the element

```javascript
const schema = new Schema({
  nodes: {
    doc: {content: 'paragraph+'},
    paragraph: {
      content: 'text*',
      toDom(node) { return ["p", {class: "p"}, 0] }
    },
    text: {},
  }
});
```

In the above example, the `0` is a hole where the content of the node is 
rendered.
Only non-leaf nodes need a hole.
Leaf nodes don't have content.

_DOM Parsing_

The `parseDOM` option is used to define a DOM parser for each node.
`parseDOM` takes an array of parse rules.

```javascript
parseDOM: [
  {tag: 'em'},
  {tag: 'i'},
  {style: 'font-style=italic'},
]
```

A DOM element matching any of these rules will be parsed into the corresponding
Document node.

### Document transformations

The transformation system leaves a trail of updates.

This is useful for:

- document history features like undo/redo
- collaborative editing system

#### Steps

An update to a document is decomposed to a set of steps.

Examples:

- `ReplaceStep`: replaces a piece of a document
- `AddMarkStep`: adds a mark to a given range

A step is applied to a document to produce a new document.

```javascript
console.log(doc.toString()) // -> p("hello")
let step = new ReplaceStep(3,5,Slice.empty);
let result = step.apply(doc);
console.log(result.doc.toString()) // -> p("heo")
```

Steps are extremely low-level and you can produce an invalid document by using 
them directly.
Instead use [helper functions](https://prosemirror.net/docs/ref/#transform.Transform.replace) 
to generate steps.

#### Transforms

To sequence steps, create a `Transform` object and apply the steps to the 
transform.

```javascript
let tr = new Transform(myDoc);
tr.delete(5,7);
tr.split(5);
```

#### Mapping

A step can give you a map.
The map will convert positions in the document before applying the step to 
positions in the document after applying the step.

```javascript
let step = new ReplaceStep(4,6,Slice.empty);
let map = ste.getMap();
console.log(map.map(8)) // -> 6
console.log(map.map(2)) // -> 2
```

A Transform object contains a `tr.mapping.map` which is the map after all steps
have been applied.

#### Rebasing

Rebasing is the process of taking two steps that start with the same document 
and sequencing them, so that one then applies to the document produced by the
other.

Rebasing is used for more complicated transformations:

- change tracking
- collaborative editing

Steps are rebased.

### The editor state

A ProseMirror state has three main components:

- `doc`: the document
- `selection`: the current selection
- `storedMarks` 

#### Selection

A selection is an instance of the Selection class or its subclasses.

Props:

- `from` and `to`: positions in the current document
- `anchor`: the unmoveable side of the selection
- `head`: the moveable side of the selection

A **text selection** are used for cursors (then `from` and `to` are the same), 
and for selected text. 
Both endpoints of a text selection are required to positions within inline 
content.

A **node selection** is a selection of the entire node. This can be useful for
structure editor-like stuff.

#### Transactions

State is updated by applying a transaction to an existing state, producing a new
state.


```javascript
const transaction = state.tr;
transaction.inserText("hello");
let newState = state.apply(transaction);
```

A Transaction is a subclass of a Transform.
A Transaction is more specific to the editor state than a Transform.
The state object has a `tr` getter method, which returns a Transaction for that 
state.
You can then operate on that Transaction.

#### Plugins

To create a plugin, instantiate the `Plugin` class and include the instance in 
the `plugins` array when instantiating `EditorState`.

```javascript
let myPlugin = new Plugin({
  props: {
    handleKeyDown(view, event) {
      console.log('A key was pressed!');
      return false; // signals event was not handled
    }
  }
});

let state = EditorState.create({schema, plugins:[myPlugin]});
```

Plugins can store their state in the editor state using a "state slot":

```javascript
let transactionCounter = new Plugin({
  state: {
    init() { return 0 },
    // This function should not mutate `value`
    // Should return a copy of `value`
    apply(tr, value) { return value + 1 }
  }
});

function getTransactionCount(state) {
  return transactionCounter.getState(state);
}
```

### The view component

> When the browser updates the DOM, the editor notices, re-parses the changed 
> part of the document, and translates the difference into a transaction.

The editor view has two general responsibilities:

- display the current state to the user
- handle user interactions with the editor

#### Data flow

DOM event -> Transaction -> new EditorState -> EditorView

`dispatchTransaction` is used to intercept a transaction as it is dispatched.
This can be used to write a ProseMirror instance into a Redux app.

```javascript
let appState = {
  editor: EditorState.create({schema}),
  score: 0,
};

let view = new EditorView(document.body, {
  state: appState.editor,
  dispatchTransaction(transaction) {
    update({type: "EDITOR_TRANSACTION", transaction});
  }
});

function update(event) {
  if (event.type === "EDITOR_TRANSACTION") {
    appState.editor = appState.editor.apply(event.transaction);
  } else if (event.type === "SCORE_POINT") {
    appState.score++;
  }
  draw();
}

function draw() {
  document.querySelector('#score').textContent = appState.score;
  view.updateState(appState.editor);
}
```

#### Props

Like React props, CodeMirror props are parameters to a UI component that define
its behavior.

```javascript
const view = new EditorView({
  state: myState,
  editable() { return false; }
  handleDoubleClick() { console.log("Double click!") }
});
```

A plugin can declare props that are provided directly to a view:

```javascript
function maxSizePlugin(max) {
  return new Plugin({
    props: {
      editable(state) { return state.doc.content.size < max; }
    }
  });
}
```

If a prop is declared multiple times, the direct declaration on the view 
instance has precedence, then each of the plugins in turn.

#### Decorations

Decorations provide some control over the way the view draws the document.
Created by returning values from the decorations prop:

- Node decorations: add styling or other DOM attributes to a single node's DOM
  representation.
- Widget decorations: insert a DOM node, which isn't part of the actual 
  document, at a given position.
- Inline decorations: add styling or attributes, much like node decorations, but
  to all inline nodes in a given range.

#### Node views

Node views specify how a node will be rendered in the DOM.

Capabilities:

- render the DOM
- define how the node is updated
- write custom code to react to events

```javascript
let view = new EditorView({
  state,
  nodeView: {
    image(node) { return new ImageView(node) }
  }
});

class ImageView {
  constructor(node) {
    this.dom = document.createElement('img');
    this.dom.src = node.attrs.src;
    this.dom.addEventListener('click', e => {
      e.preventDefault();
      console.log('Clicked')
    })
  }
  // tells ProseMirror to ignore events emitted by this node 
  stopEvent() { return true; }
}
```

### Commands

A command is a function that implements an editing action.
The user can perform the editing action by pressing a key combination or 
interaction with a menu.

Commands take an editor state and a dispatch function, and return a boolean:

```javascript
function deleteSelection(state, dispatch) {
  if (state.selection.empty) { 
    return false; 
  }
  if (dispatch) {
    dispatch(state.tr.deleteSelection());
  }
  return true;
}
```

Commands should return `false` when they aren't applicable.
Otherwise they should both dispatch the transaction and return true.

`dispatch` is optional, and should always be tested for before it is called.
ProseMirror will sometimes call a command function without providing `dispatch`
in order to test whether the command applies.
That is the utility of returning `true` - it can test whether the command 
applies without having the command do the update.

**Commands don't have to dispatch a transaction**.
A command is called to trigger a side-effect.
This is often dispatching a transaction.
But it can be something like opening a modal too.

Each command should encapuslate one behavior.
Commands can be composed using the `chainCommands` function.

